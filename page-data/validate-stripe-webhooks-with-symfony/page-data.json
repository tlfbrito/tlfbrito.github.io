{"componentChunkName":"component---src-templates-blog-post-js","path":"/validate-stripe-webhooks-with-symfony/","result":{"data":{"site":{"siteMetadata":{"title":"Tiago Brito","author":"Tiago Brito"}},"markdownRemark":{"id":"0c57b937-f06b-5f82-ab77-0094088dc0ad","html":"<p>Recently we have changed our payment system at <a href=\"https://www.uniplaces.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Uniplaces</a>. Some of payment providers are asynchronous to confirm the\npayment charge (e.g. bank transfers). To handle this asynchronous process we rely on Stripe webhooks to confirm payments.\nWhen we receive a payment confirmation we need to be sure that the request is actually coming from Stripe and not from\nsomewhere else trying to confirm a payment that didn’t exist. To archive this, we needed to add an extra security layer\nto validate all the webhooks requests.</p>\n<p>Usually, you would use a Middleware (e.g. <a href=\"https://laravel.com/docs/5.4/middleware\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Laravel middleware</a>,\n<a href=\"https://golang.org/pkg/net/http/#HandleFunc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HandlerFunc in Golang</a>, etc) to tackle this type of problems.\nSymfony doesn’t use middleware architecture, instead, it uses Kernel Events\nto allow developers to hook into the Request->Response workflow.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3abd6edaf946feeb3fc7f786f19dfe29/1e043/symfony-request-lifecyle-workflow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.13513513513513%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABuklEQVQoz3VSTW/TQBD1b+PM/+EncOHGAVSpEr0AFzhQlUogIi6RUFukVE1EKrUlpE3sOo7jxt6PmdnZZdYmkIJ4Xu2ud97M7L6ZBDbQRmmriNBtgeVrQRvAFpJuQcRlnWXVDw2NZ8/iJJCVN0GcE47WmmTBLWf5cyQ2QIKWBI2qlW5kWDDdXSRnayJjQXbR1ULSmiQweXZekgZJGMnsItsHOYyEzqoMzRbyOmRisJiAM7JB8sqSd4Hr4MGLE3LwHEIT2ASBMjEEIlciixCjr01eHT/5MNo97Ke7n9Lz99nbB6Phzvzdl9mzg5vh0e3Bw3H/0eSmuHv65rI/LC9T/Xw/G15fvT55fDjaS77dHk1XZ5MMTqem+m5Ge1kxaK4WMJjYMrfjl+m0t9JAnwfldY7zct07LRbr+izrjfPjJPjQDnktBe/jFUM338MszZgDOG2p6igiQgIo6sUCIlGsKnWV7WrFhCIfW/QvPhZfL0qFeW1q0XF5p5dVE0v1q/wiuPf8D+RIwl7MqVgLQXII3+Urs1jpP02ijLIioTSBENzfIwQUsYGiyLhB8rvXlI7O7j+IF4thcLs9fwKwcqwlvmzENQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Request -&gt; Response workflow\"\n        title=\"Request -&gt; Response workflow\"\n        src=\"/static/3abd6edaf946feeb3fc7f786f19dfe29/fcda8/symfony-request-lifecyle-workflow.png\"\n        srcset=\"/static/3abd6edaf946feeb3fc7f786f19dfe29/12f09/symfony-request-lifecyle-workflow.png 148w,\n/static/3abd6edaf946feeb3fc7f786f19dfe29/e4a3f/symfony-request-lifecyle-workflow.png 295w,\n/static/3abd6edaf946feeb3fc7f786f19dfe29/fcda8/symfony-request-lifecyle-workflow.png 590w,\n/static/3abd6edaf946feeb3fc7f786f19dfe29/1e043/symfony-request-lifecyle-workflow.png 690w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The <a href=\"http://symfony.com/doc/current/components/http_kernel.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HttpKernel component</a> provides an interface that formalizes the process of starting with a request and\ncreating the appropriate response.</p>\n<p>Internally this handle function is responsible for transforming the Request into the Response following the\nprevious workflow. In each step, Symfony will dispatch an event that can be listened by multiple listeners.</p>\n<h3 id=\"stripe-request-subscriber\"><a href=\"#stripe-request-subscriber\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stripe Request Subscriber</h3>\n<p>Our task is simple. Create our listener to validate Stripe requests and subscribe it to correct kernel event.\nAs Symfony documentation describe in their website for\n<a href=\"http://symfony.com/doc/current/components/http_kernel.html#the-kernel-request-event\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">kernel.request event</a>:</p>\n<blockquote>\n<p>Typical Purposes: To add more information to the Request, initialize parts of the system, or return a Response\nif possible (e.g. a security layer that denies access).</p>\n</blockquote>\n<p>This is a perfect fit for our use case because, we want to deny access for requests that don’t come from Stripe.\nLets create our Subscriber and subscribe it to <code class=\"language-text\">KernelEvents::REQUEST</code> Event and define what method do we what to execute\n<code class=\"language-text\">onKernelRequest()</code>.</p>\n<p>Behind the scenes, the <code class=\"language-text\">validateWebhook()</code> implementation is using the <code class=\"language-text\">\\Stripe\\Webhook::constructEvent</code> from\n<a href=\"https://stripe.com/docs/webhooks#verify-official-libraries\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Stripe SDK</a> to validate the request header signature.</p>\n<hr>","timeToRead":2,"frontmatter":{"title":"Validate Stripe webhooks with Symfony","date":"July 05, 2017","spoiler":"If you are familiar with AWS DynamoDB client for PHP they already do the hard work of handling multiple paginated results using the ResultPaginator."},"fields":{"slug":"/validate-stripe-webhooks-with-symfony/","langKey":"en","tags":["symfony","stripe","webhooks","php","api"]}}},"pageContext":{"slug":"/validate-stripe-webhooks-with-symfony/","previous":{"fields":{"slug":"/dynamodb-on-demand-hydrator/","langKey":"en","directoryName":"dynamodb-on-demand-hydrator","maybeAbsoluteLinks":["/house-rules-on-search/"]},"frontmatter":{"title":"DynamoDb OnDemand Hydrator"}},"next":{"fields":{"slug":"/dynamodb-on-demand-hydrator-with-generators/","langKey":"en","directoryName":"dynamodb-on-demand-hydrator-with-generators","maybeAbsoluteLinks":["/dynamodb-on-demand-hydrator/"]},"frontmatter":{"title":"DynamoDb on Demand Hydrator with Generators"}},"translations":[],"translatedLinks":[]}}}